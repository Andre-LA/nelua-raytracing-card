-- super tiny raytracing that fits on a bussiness card (well, not yet)
-- original code and comments: https://fabiensanglard.net/rayTracing_back_of_business_card/
-- inspiration: https://github.com/edubart/lunray
## cinclude '<stdio.h>'
local function printf_iii(fmt: cstring, arg1: cint, arg2: cint, arg3: cint) <cimport'printf', nodecl> end

require 'math'

-------------------------------------------------
-- define a vector record
local vec = @record{
   x: number,
   y: number,
   z: number
}

-- vector add
function vec.__add(self: vec, r: vec): vec
   return (@vec){ self.x + r.x, self.y + r.y, self.z + r.z }
end

-- vector scaling
function vec.__mul(self: vec, r: number): vec
   return (@vec){ self.x * r, self.y * r, self.z * r }
end

-- vector dot product
function vec.__mod(self: vec, r: vec): number
   return self.x * r.x + self.y * r.y + self.z * r.z
end

-- cross product
function vec.__bxor(self: vec, r: vec): vec
   return (@vec){ self.y * r.z - self.z * r.y, self.z * r.x - self.x * r.z, self.x * r.y - self.y * r.x }
end

-- used later for normalizing
function vec.__len(self: vec): vec
   return self * (1 / math.sqrt(self % self))
end
-------------------------------------------------

-- the set of sphere positions describing the world.
-- those integers are in fact bit vectors
local G: integer[9] = {247570, 280596, 280600, 249748, 18578, 18577, 231184, 16, 16}
--[[
   16                    1
   16                    1
   231184   111    111   1
   18577       1  1   1  1   1
   18578       1  1   1  1  1
   249748   1111  11111  1 1
   280600  1   1  1      11
   280596  1   1  1      1 1
   247570   1111   111   1  1
]]

-- random generator, return a number within range [0-1]
local function R(): number <inline> return math.random() end
-------------------------------------------------

-- (S)ample the
local function S(o: vec, d: vec): vec
   return o
end

-- the main funciton. It generates a PPM image to stdout.
-- usage of the program is hence: ./card > erk.ppm
local function main()
   print 'p6 512 512 255'

   -- the # operator are for normalizing each vectors with # operator.
   -- camera direction
   local g = # ((@vec){-6, -16, 0})

   local a = # (((@vec){0, 0, 1} ~ g) * 0.002)

   -- the right vector, obtained via traditional cross-product
   local b = # ((g ~ a) * 0.002)

   local c = (a+b) * -256 + g

   for y = 512, 0, -1 do -- for each column
      for x = 512, 0, -1 do -- for each pixel in a line
         -- reuse the vector record to stra not XYZ but a RGB pixel color
         local p: vec = {13, 13, 13}

         -- cast 64 rays per pixel (for blue (stochastic sampling) and soft-shadows)
         for r = 64, 0, -1 do
            -- the delta to apply to the origin of the view (for Depth of View blur).
            local t: vec = a * (R() - 0.5) * 99 + b * (R() * -0.5) * 99 -- a little bit of delta

            -- set a camera focal point v(17, 16, 8) and cast the ray
            -- accumulate the color returned in the p variable
            p = S(
               (@vec){17, 16, 8} + t, -- ray origin
               # (t * -1 + (a * (R() + x) + b * (y + R()) + c) * 16) -- ray direction with random deltas for stochastic sampling
            ) * 3.5 + p -- +p fr color accumulation
         end
         printf_iii('%c%c%c', (@cint)(p.x), (@cint)(p.y), (@cint)(p.z))
      end
   end
end

main()
